# Chapter 03  

## OCP 개방/폐쇄 원칙  
- 인터페이스를 사용하여 반복 로직과 비즈니스 로직의 결합을 제거할 수 있다.  
- 기존 메소드의 바디를 바꿀 필요 없이 새로운 구현을 인수로 전달한다.  
- 따라서 변경 없이도 확장성은 개방된다.  
- 새로운 요구 사항에 맞는 필터를 구현한 후, 메소드의 인수로 필터의 인스턴스를 전달한다.  
- 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.  
- 결합도가 낮아지므로 코드 유지보수성이 좋아진다.  

## 람다 표현식  
- 새로운 요구 사항이 있을 떄마다 별도의 클래스를 만들어야 한다.  
- 람다 표현식을 이용해 이름 없이 인터페이스 구현 객체를 코드 블록 형태로 전달할 수 있다.  

## 갓 인터페이스    
- 한 인터페이스에 모든 기능을 추가한 방식  
- 보통 작은 인터페이스를 권장한다.  
- 그래야 도메인 객체의 다양한 내부 연산으로의 디펜던시를 최소화할 수 있다.  

## 도메인 클래스 vs 원싯값  
- 원싯값으로는 다양한 결과를 반환할 수 없어 유연성이 떨어진다.  
- double을 감싸는 새 도메인 클래스 Summary를 만드는 것이 좋다.  
- 새 클래스에 필요한 필드와 결과를 언제든 추가할 수 있다.  

## 자바 예외 처리  
- 자바는 예외를 일급 언어 기능으로 추가하고 다음과 같은 장점을 제공한다.  
    - 문서화 : 메소드 시그니처 자체에 예외를 지원
    - 형식 안전성 : 개발자가 예외 흐름을 처리하고 있는지를 형식 시스템이 파악  
    - 관심사 분리 : 비즈니스 로직과 예외 회복이 각각 try/catch 블록으로 구분
- 다만 예외 기능으로 복잡성이 증가한다.  

## 자바 예외 클래스  
- 자바는 두 종류의 예외를 지원한다.  
    - 확인된 예외 : 회복해야 하는 대상의 예외. try/catch로 처리.  
        - Exception  
    - 미확인 예외 : 언제든 발생할 수 있는 예외. 꼭 처리할 필요가 없음.      
        - Error, RuntimeException  
- 대다수의 예외를 미확인 예외로 지정하고 꼭 필요한 상황에서만 확인된 예외로 지정해 불필요한 코드를 줄여야 한다.  
  
## 노티피케이션 패턴  
- 도메인 클래스로 오류를 수집하는 패턴  
- 너무 많은 미확인 예외를 사용하는 상황에서 적합한 해결책을 제공한다.  

## 예외 사용 가이드라인
- 문제의 근본 원인을 알 수 없다고 예외를 무시하면 안 된다.  
- RuntimeException과 같은 일반적인 예외는 잡지 않는다.  
- @throws Javadoc으로 예외를 문서화한다.  
- 특정 구현에 종속된 예외를 주의한다.  
- 예외로 흐름을 제어하지 않는다. 가독성을 떨어트리고 코드의 의도도 이해하기 어려워진다.  

## Optional\<T>  
- Java 8 값이 없는 상태를 표현하는 내장 데이터 형식  
- 버그의 범위를 줄이는 데 도움이 된다.  
- 다양한 Optional 객체를 조합할 수 있다.  

## Try\<T>  
- 성공하거나 실패할 수 연산을 가리키는 데이터 형식  
- JDK는 지원하지 않아 외부 라이브러리를 이용해야 한다.  

